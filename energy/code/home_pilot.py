import numpy as np
import pandas as pd
import glob
from numpy import genfromtxt
from gurobipy import *


#from energy.code.hvac.real_hvac import real_hvac
#from energy.code.ev.real_ev import real_ev

DATA_MAIN="/energy/data"



class Home:
    def __init__(self,time_res=15, horizon=96, current_time=None, 
                  first_idx_to_charge_ev=0, home_num=None,num_hvac_vectors=1,
                  hvac_angle_threshold=0.1,hvac_trajectories_from_a_file=False,
                  rng=None,source_path=None,price_flexibility=None,
                  optimize_bill=None):

        self.time_res=time_res
        self.horizon=horizon
        self.current_time=current_time
        self.price_flexibility = price_flexibility
        self.optimize_bill = optimize_bill
        
        # Set data folder
        self.home_data_location = source_path + DATA_MAIN + "/home_"+str(home_num+1)
        self.home_num=home_num
        
        folders=glob.glob(self.home_data_location+"//*")
        
        # During initialization we assume that the home has no EV, hence we set
        # the number of trajectories to 0.
        self.no_ev = True
        self.num_ev_vectors = 0
        ev_path = None
        hvac_path= None
        self.hvac_csv_path = None
        for f_name in folders:
            if 'ev_csv' in f_name:
                self.no_ev = False
                self.ev_csv_path=f_name
            if f_name[-4:] == 'hvac':
                hvac_path = f_name
            if 'hvac_csv' in f_name:
                self.hvac_csv_path=f_name 


        
        
        """
            Appliances
            Home must have appliances.
            
            We no longer create the EV object since we are going to read trajectories from
            a file as in the HVAC.
        """
        # if self.no_ev == False:
        #     # Read EV trajectories from a file.
            
        #     self.ev=real_ev(start_idx=first_idx_to_charge_ev,time=current_time,time_interval=self.time_res,read_data=ev_path)
            
        #     self.ev_battery=self.ev.available_charge
        #     self.target=self.ev.target_charge_level

        self.hvac_trajectories_from_a_file = hvac_trajectories_from_a_file
        if self.hvac_trajectories_from_a_file == False:
            print("The code should never enter here if you want to read trajectories from a csv file ! This statement is generated by home_pilot.py")
            from energy.code.hvac.real_hvac import real_hvac
            self.hvac=real_hvac(home_num+1, 'LSODA',0.5, self.home_num, read_data=hvac_path)
        


            self.hvac_feasible=[]
            
            self.num_hvac_vectors_per_approach=num_hvac_vectors
    
    
            
            
            self.hvac_feasible=[]
            self.set_temperatures=[]
            self.corresp_hvac_schedule=[]
            self.hvac_similarity_scores=[]
            self.hvac_modified=[]
            self.v_norm=[]
            
            
            self.hvac_angle_threshold=hvac_angle_threshold
            self.p_list=[0.9,0.7,0.5,0.3,0.1]
        
        
        self._setup()
        
        
        
    
    
    def modify_hvac(self,hvac_activity):
        
        
        hvac_activity=hvac_activity[:-1]
        
        hvac_activity=hvac_activity.reshape((-1,self.no_cols))
        hvac_activity=np.mean(hvac_activity,axis=1)
        
        return hvac_activity
        
    
    
    def _setup(self):
        
        
        if self.no_ev == False:
            ev_csv_file=self.ev_csv_path+"/ev_schedules.csv"
            
            self.ev_modified=genfromtxt(ev_csv_file, delimiter=',')
            
            # Even if ev_schedules.csv includes a single ev vector,
            # self.ev_modified should be a 2-dimensional array 
            # with dimensions 1*horizon. Make sure that this is the case.
            if len(self.ev_modified.shape) == 1:
                self.ev_modified = np.expand_dims(self.ev_modified,axis=0)
            assert len(self.ev_modified.shape) == 2, f"self.ev_modified should be a 2-dimensional array but the length of its shape is {len(self.ev_modified.shape)}"
                
            #The length of the ev vector should match the specified horizon
            assert self.ev_modified.shape[1] == self.horizon, f"horizon is set to {self.horizon}, but the length of the provided ev vector in ev_schedules.csv is {self.ev_modified.shape[1]} for home {self.home_num+1}"
            
            self.ev_modified = list(self.ev_modified)
            self.num_ev_vectors=len(self.ev_modified)
            
        
        if self.hvac_trajectories_from_a_file:
            #raise NotImplementedError()
            
            
            csv_file=self.hvac_csv_path+"/hvac_schedules.csv"
            
            self.hvac_modified=genfromtxt(csv_file, delimiter=',')
            
            # Even if hvac_schedules.csv includes a single HVAC vector,
            # self.hvac_modified should be a 2-dimensional array 
            # with dimensions 1*horizon. Make sure that this is the case.
            if len(self.hvac_modified.shape) == 1:
                self.hvac_modified = np.expand_dims(self.hvac_modified,axis=0)
            assert len(self.hvac_modified.shape) == 2, f"self.hvac_modified should be a 2-dimensional array but the length of its shape is {len(self.hvac_modified.shape)}"
                
            #The length of the hvac vector should match the specified horizon
            assert self.hvac_modified.shape[1] == self.horizon, f"horizon is set to {self.horizon}, but the length of the provided hvac vector in hvac_schedules.csv is {self.hvac_modified.shape[1]} for home {self.home_num+1}"
            
            self.hvac_modified = list(self.hvac_modified)
            self.num_hvac_vectors=len(self.hvac_modified)
            
        else:
        
            home_data=self.hvac.get_data()
    
    
            lower=home_data['lower_temperature']
            upper=home_data['upper_temperature']
            nominal_set=home_data['set_temperature']
            
            self.hvac_time = (self.hvac.t[1] - self.hvac.t[0]).seconds
            self.hvac_time = self.hvac_time // 60 #convert it to minutes.
            
            
            self.no_cols=1
            if self.hvac_time != self.time_res:
                if self.time_res > self.hvac_time:
                    self.no_cols=self.time_res // self.hvac_time
                else:
                    raise ValueError("HVAC time is greater than the specified time_res")
            
            
            
            
            """
            Start Creating HVAC schedules
            """
            #Nominal Schedule
            self.set_temperatures.append(nominal_set)
            self.nominal_hvac_power=self.hvac.find_hvac_schedule_for_set_old(nominal_set)
            self.hvac_feasible=np.expand_dims(self.nominal_hvac_power,-1)
            self.v_norm.append(np.sqrt(np.dot(self.nominal_hvac_power,self.nominal_hvac_power)))
            modified_activity=self.modify_hvac(self.nominal_hvac_power)
            self.hvac_modified.append(modified_activity)
            
            
            #Most Schedule
            self.set_most=self.hvac.sample_work_most(lower,upper)
            self.set_temperatures.append(self.set_most)
            hvac_activity = self.hvac.find_hvac_schedule_for_set_old(self.set_most)
            self.hvac_feasible=np.concatenate([self.hvac_feasible,np.expand_dims(hvac_activity,-1)],axis=1)
            self.v_norm.append(np.sqrt(np.dot(hvac_activity,hvac_activity)))
            modified_activity=self.modify_hvac(hvac_activity)
            self.hvac_modified.append(modified_activity)
            
            
            #Least Schedule
            self.set_least=self.hvac.sample_work_least(lower,upper)
            self.set_temperatures.append(self.set_least)
            hvac_activity = self.hvac.find_hvac_schedule_for_set_old(self.set_least)
            self.hvac_feasible=np.concatenate([self.hvac_feasible,np.expand_dims(hvac_activity,-1)],axis=1)
            self.v_norm.append(np.sqrt(np.dot(hvac_activity,hvac_activity)))
            modified_activity=self.modify_hvac(hvac_activity)
            self.hvac_modified.append(modified_activity)
            
            #mixture model
            for p in self.p_list:
                
                i=0
                while i<self.num_hvac_vectors_per_approach:
                    print("Home: %d Mixture_p:%f Vector:%d"%(self.home_num,p,i+1))
                    candidate_set=self.hvac.mix_extremes(self.set_most,self.set_least,p)
                    hvac_activity = self.hvac.find_hvac_schedule_for_set_old(candidate_set)
                    #self.hvac.get_temperature(hvac_activity)
                    
                    v_norm_tmp=np.sqrt(np.dot(hvac_activity,hvac_activity))
                    cosines=np.dot(hvac_activity,self.hvac_feasible) / (v_norm_tmp * np.array(self.v_norm))
                    degrees=np.arccos(cosines)/np.pi
                    i=i+1
                    
                    if np.all(degrees > self.hvac_angle_threshold):
                    #if np.all(np.dot(hvac_activity,hvac_feasible) < np.array(hvac_similarity_scores) * threshold):
                        
                        self.set_temperatures.append(candidate_set)
                        self.hvac_feasible=np.concatenate([self.hvac_feasible,np.expand_dims(hvac_activity,-1)],axis=1)
                        self.v_norm.append(v_norm_tmp)
                        modified_activity=self.modify_hvac(hvac_activity)
                        self.hvac_modified.append(modified_activity)
                    else:
                        print('similar vector')
            
            #Truncated Gaussian Model
            i=0
            while i<self.num_hvac_vectors_per_approach:
                print("Home: %d Gaussian Vector:%d"%(self.home_num,i+1))
                candidate_set=self.hvac.sample_set(lower,upper)
                hvac_activity = self.hvac.find_hvac_schedule_for_set_old(candidate_set)
                #self.hvac.get_temperature(hvac_activity)
                
                v_norm_tmp=np.sqrt(np.dot(hvac_activity,hvac_activity))
                cosines=np.dot(hvac_activity,self.hvac_feasible) / (v_norm_tmp * np.array(self.v_norm))
                degrees=np.arccos(cosines)/np.pi
                i=i+1
                
                if np.all(degrees > self.hvac_angle_threshold):
                #if np.all(np.dot(hvac_activity,hvac_feasible) < np.array(hvac_similarity_scores) * threshold):
                    
                    self.set_temperatures.append(candidate_set)
                    self.hvac_feasible=np.concatenate([self.hvac_feasible,np.expand_dims(hvac_activity,-1)],axis=1)
                    self.v_norm.append(v_norm_tmp)
                    modified_activity=self.modify_hvac(hvac_activity)
                    self.hvac_modified.append(modified_activity)
                else:
                    print('similar vector')
            
            #Sequential Model
            i=0
            p=0.5
            while i<self.num_hvac_vectors_per_approach:
                print("Home: %d Sequential_p:%f Vector:%d"%(self.home_num,p,i+1))
                candidate_set=self.hvac.sequential(self.set_most,self.set_least,p)
                hvac_activity = self.hvac.find_hvac_schedule_for_set_old(candidate_set)
                #self.hvac.get_temperature(hvac_activity)
                
                v_norm_tmp=np.sqrt(np.dot(hvac_activity,hvac_activity))
                cosines=np.dot(hvac_activity,self.hvac_feasible) / (v_norm_tmp * np.array(self.v_norm))
                degrees=np.arccos(cosines)/np.pi
                i=i+1
                
                if np.all(degrees > self.hvac_angle_threshold):
                #if np.all(np.dot(hvac_activity,hvac_feasible) < np.array(hvac_similarity_scores) * threshold):
                    
                    self.set_temperatures.append(candidate_set)
                    self.hvac_feasible=np.concatenate([self.hvac_feasible,np.expand_dims(hvac_activity,-1)],axis=1)
                    self.v_norm.append(v_norm_tmp)
                    modified_activity=self.modify_hvac(hvac_activity)
                    self.hvac_modified.append(modified_activity)
                else:
                    print('similar vector')
            
            
            k_list=[48,96]
            for k in k_list:
                num_vecs=(len(self.set_most) // k)
                i=0
                while i<num_vecs:
                    print("Home: %d Piecewiseconstant_k:%d Vector:%d"%(self.home_num,k,i+1))
                    candidate_set=self.hvac.piecewiseConst(self.set_most,self.set_least,k)
                    hvac_activity = self.hvac.find_hvac_schedule_for_set_old(candidate_set)
                    #self.hvac.get_temperature(hvac_activity)
                    
                    v_norm_tmp=np.sqrt(np.dot(hvac_activity,hvac_activity))
                    cosines=np.dot(hvac_activity,self.hvac_feasible) / (v_norm_tmp * np.array(self.v_norm))
                    degrees=np.arccos(cosines)/np.pi
                    i=i+1
                    
                    if np.all(degrees > self.hvac_angle_threshold):
                    #if np.all(np.dot(hvac_activity,hvac_feasible) < np.array(hvac_similarity_scores) * threshold):
                        
                        self.set_temperatures.append(candidate_set)
                        self.hvac_feasible=np.concatenate([self.hvac_feasible,np.expand_dims(hvac_activity,-1)],axis=1)
                        self.v_norm.append(v_norm_tmp)
                        modified_activity=self.modify_hvac(hvac_activity)
                        self.hvac_modified.append(modified_activity)
                    else:
                        print('similar vector')
            
            
            #print('can')
            print("%d HVAC Vectors generated for home %d"%(self.hvac_feasible.shape[1],self.home_num))
            self.num_hvac_vectors=len(self.hvac_modified)
            #np.savetxt("hvac_schedules.csv", np.array(self.hvac_modified), delimiter=",")
        
        
                
        
        
        
        
        
        

    
    def modify_hvac_activity(self,hvac_activity,candidate_set):
        
        """
        This function should return HVAC activity vector in the length of 
        self.horizon. 
        
        Currrently, we only make this transformation. Before applying this transformation
        we can apply some modifications to the hvac_activity as well. In this scenario,
        We have to update candidate set temperature we utilize to generate the hvac_activity 
        vector. That is why I am passing candidate_set variable into this function, and storing
        them in an appropriate list. We have to be careful while making modificiations, and make
        sure that we keep logs properly.
        """
        
        self.set_temperatures.append(candidate_set) # we need to store candidate 
        #set temperatures because they want us to deliver this as output instead of
        #the hvac activity.
        self.corresp_hvac_schedule.append(hvac_activity) # We still store
        #hvac activity corresponding to the candidate set temperature. We need to save this
        #before changing the size of hvac_activity
        
        
        hvac_activity=hvac_activity[:-1]
        
        hvac_activity=hvac_activity.reshape((-1,self.no_cols))
        hvac_activity=np.mean(hvac_activity,axis=1)
        
        

        
        return hvac_activity
        
            
        
    # def total_desirable_load(self,price,normalize):
    #     total=self.ewh_desirable_load+self.ev_desirable_load+\
    #         self.hvac_desirable_load+self.refrigerator_desirable_load+\
    #         self.oven_desirable_load+self.wm_desirable_load+\
    #         self.dryer_desirable_load
            
            
    #     daily_fee=(np.dot(total,price))*(self.wm.time_r/60)#to convert kwh in 15minutes
    #     """
    #     TODO
    #         daily_budget must be a home specific parameter.
    #         discuss cost_u calculation deviation.
    #     """
    #     daily_budget=15
    #     if self.s_effect==-1:
    #         daily_budget=10
        
    #     if daily_fee <= daily_budget:
    #         #in this case, home does not have any incentive to deviate from desirable load.
    #         cost_u={'ewh':1000.0,
    #                 'ev':1000.0,
    #                 'hvac':1000.0,
    #                 'oven':1000.0,
    #                 'wm':1000.0,
    #                 'dryer':1000.0}
    #     else:
    #         correction_amount=abs(daily_fee-daily_budget)/(normalize*100)
    #         #correction_amount=abs(daily_fee-daily_budget)
            
    #         total_ewh=np.sum(self.ewh_desirable_load)
    #         total_ev=np.sum(self.ev_desirable_load)
    #         total_hvac=np.sum(self.hvac_desirable_load)
    #         total_refrigerator=np.sum(self.refrigerator_desirable_load)
    #         total_oven=np.sum(self.oven_desirable_load)
    #         total_wm=np.sum(self.wm_desirable_load)
    #         total_dryer=np.sum(self.dryer_desirable_load)
            
    #         tmp_total=np.sum(total)
    #         cost_u={'ewh':correction_amount*(total_ewh/tmp_total),
    #                 'ev':correction_amount*(total_ev/tmp_total),
    #                 'hvac':correction_amount*(total_hvac/tmp_total),
    #                 'oven':correction_amount*(total_oven/tmp_total),
    #                 'wm':correction_amount*(total_wm/tmp_total),
    #                 'dryer':correction_amount*(total_dryer/tmp_total)}
        
    #     return total,cost_u,daily_fee
            
            
        
        

    def optimize_mpc(self,price):

        
        horizon=self.horizon
        m = Model("home_mpc")
        

        obj_ev_price=0.0
        obj_hvac_price=0.0

        #self.ev_start_charging=int(self.ev.start*(60//self.time_res))

        
        
        
        #necessary parameters

        #power_ev=self.ev.nominal_power
        #self.modified_charge_rate=self.ev.charge_rate * (self.time_res/60)

        #necessary parameters
        sign_of_dual_variable=[]
        sign_of_dual_constraint=[]
        num_variables=0
        num_helper_variables=0

        
        
            #power variables
        P_HVAC=m.addVars(horizon,lb=0,name="hvac_real")
        P_ev=m.addVars(horizon,lb=0,name="ev_real")
        num_variables+=horizon*1+horizon
        sign_of_dual_constraint=[-1]*num_variables
            
            #helper variables
                #ewh related
        #t_ewh=m.addVars(horizon+1,lb=0)#commented out
        #z_ewh=m.addVars(horizon,lb=0)
        #y_ewh=m.addVars(horizon,lb=0)
                #ev related
        #x_ev=m.addVars(ev_horizon+1,lb=0)
        #i_ev=m.addVars(horizon,lb=0)
                #HVAC related
        #s_HVAC_neg=m.addVars(horizon,lb=0)
        #s_HVAC_pos=m.addVars(horizon,lb=0)
        #T_in=m.addVars(horizon+1,lb=-GRB.INFINITY)
        hvac_assign=m.addVars(self.num_hvac_vectors,vtype=GRB.BINARY,name="hvac_assignment")
        ev_assign=m.addVars(self.num_ev_vectors,vtype=GRB.BINARY,name="ev_assignment")
        """
        add T_set as decision variable to govern on/off of HVAC.
        """
        #T_set=m.addVars(horizon,lb=-GRB.INFINITY)
                #pv related
        #x_pv=m.addVars(horizon+1,lb=0)
        #sign_of_dual_constraint.extend([-1]*(1*horizon+1))
        sign_of_dual_constraint.extend([-1]*(self.num_hvac_vectors+self.num_ev_vectors))
        #sign_of_dual_constraint.extend([0]*(1*horizon+1))
        #sign_of_dual_constraint.extend([-1]*(1*horizon+1))#commented out
                #other deviations
        #u_wm=m.addVars(horizon,lb=-GRB.INFINITY,name="wm_signed_dev")
        #u_oven=m.addVars(horizon,lb=-GRB.INFINITY,name="oven_signed_dev")
        #u_dryer=m.addVars(horizon,lb=-GRB.INFINITY,name="dryer_signed_dev")
        #u_HVAC=m.addVars(horizon,lb=-GRB.INFINITY,name="hvac_signed_dev")
        #u_ewh=m.addVars(horizon,lb=-GRB.INFINITY,name="ewh_signed_dev")
        #u_ev=m.addVars(horizon,lb=-GRB.INFINITY,name="ev_signed_dev")
        
        #num_helper_variables+=horizon*6
        #num_helper_variables+=horizon*2#previous version:horizon*4+(horizon+1)*4
        num_helper_variables+=self.num_ev_vectors+self.num_hvac_vectors+horizon+1
        num_variables+=num_helper_variables
        #sign_of_dual_constraint.extend([0]*(6*horizon))
        
        # #integer programming
        # wm_on_off=m.addVars(horizon,vtype=GRB.BINARY,name="wm_on_off")
        # wm_start=m.addVars(horizon,vtype=GRB.BINARY,name="wm_start")
        # wm_shut=m.addVars(horizon,vtype=GRB.BINARY,name="wm_shut")
        
        # oven_on_off=m.addVars(horizon,vtype=GRB.BINARY,name="oven_on_off")
        # oven_start=m.addVars(horizon,vtype=GRB.BINARY,name="oven_start")
        # oven_shut=m.addVars(horizon,vtype=GRB.BINARY,name="oven_shut")
        
                
        # dryer_on_off=m.addVars(horizon,vtype=GRB.BINARY,name="dryer_on_off")
        # dryer_start=m.addVars(horizon,vtype=GRB.BINARY,name="dryer_start")
        # dryer_shut=m.addVars(horizon,vtype=GRB.BINARY,name="dryer_shut")
        
        
        
   
            
        

        
        
        #dummy objective function constructio
        
        p_obj=quicksum(P_HVAC[i]*price[i] for i in range(horizon))+\
                quicksum(P_ev[i]*price[i] for i in range(horizon))
        
        m.setObjective(p_obj,GRB.MINIMIZE)

        modified_c=np.array([])

        modified_c=np.concatenate((modified_c,price))#hvac
        #modified_c=np.concatenate((modified_c,power_ewh*price))#ewh
        modified_c=np.concatenate((modified_c,price))#ev
        #modified_c=np.concatenate((modified_c,-price))#pv
        
        modified_c=np.concatenate((modified_c,np.repeat(0,num_helper_variables)))#cost is zero for other vars.
        
        
        



        
        
        """
        ________________________HVAC__________________________
        """
        
        
        
        
        
        
        #hvac constraints
        
        
        
        const_HVAC_real_pow=m.addConstrs((P_HVAC[i]==quicksum(hvac_assign[k]*self.hvac_modified[k][i] for k in range (self.num_hvac_vectors))
                                              for i in range(horizon)),name='c_HVAC_realpow')
        
        sign_of_dual_variable.extend([0]*(horizon))
        
        select_one=m.addConstr(quicksum(hvac_assign[k] for k in range(self.num_hvac_vectors)) == 1,name='c_hvac_init_temp')
        sign_of_dual_variable.extend([0]*(1))
        
        
     
     
        """
        ________________________EV__________________________
        """
        
        if self.no_ev == True:
            
            ev_dummy_before_arrival=m.addConstrs((P_ev[i]==0 for i in range(horizon)),name='no_ev')
        
            
        else:
            
                    
            const_ev_real_pow=m.addConstrs((P_ev[i]==quicksum(ev_assign[k]*self.ev_modified[k][i] for k in range (self.num_ev_vectors))
                                                  for i in range(horizon)),name='c_ev_realpow')
            
            sign_of_dual_variable.extend([0]*(horizon))
            
            select_one=m.addConstr(quicksum(ev_assign[k] for k in range(self.num_ev_vectors)) == 1,name='c_ev_init_temp')
            sign_of_dual_variable.extend([0]*(1))
        
            
            # We no longer use the code below since we start considering ev trajectories !
            # start
            # -----------------------------
            # -----------------------------
            # -----------------------------
            # -----------------------------
            # -----------------------------
            
            # #EV is not at home. So, it is not chargeable.
            # if self.ev.K_ev_charging_duration is None:
            #     ev_dummy_before_arrival=m.addConstrs((P_ev[i]==0 for i in range(horizon)),name='EV_is_not_at_home')
            # else:
                
                
            #     #new
            #     self.ev_start_charging = self.ev.ev_start_charging
            #     power_ev=self.ev.nominal_power
            #     self.modified_charge_rate=self.ev.charge_rate * (self.time_res/60)
                
            #     nominal_power_limit=m.addConstrs((P_ev[i]<=power_ev for i in range(horizon)),name='c_ev_realpow_up')
                
            #     self.K_ev_charging_duration = self.ev.K_ev_charging_duration
            #     finish_charging=self.ev_start_charging+self.K_ev_charging_duration
            #     K_ev_charging=self.ev_start_charging+np.arange(0,self.K_ev_charging_duration)
            
                
                
                
            #     required_charge_before_leave=self.ev.target_charge_level - self.ev_battery
            #     if self.K_ev_charging_duration*self.modified_charge_rate<=required_charge_before_leave:
            #         #Not enough time to charge battery. Start charging immediately when car is available.
            #         ev_dummy_before_arrival=m.addConstrs((P_ev[i]==0 for i in range(self.ev_start_charging)),name='charge_battery_until_leave')
            #         ev_charge=m.addConstrs((P_ev[self.ev_start_charging+i]==self.ev.nominal_power for i in range(self.K_ev_charging_duration)),name='charge_battery_until_leave')
            #         ev_dummy=m.addConstrs((P_ev[finish_charging+i]==0 for i in range(horizon-(self.ev_start_charging+self.K_ev_charging_duration))),name='charge_battery_until_leave')
                
            #     else:
                
                    
                    
            #         z_ev=[]
            #         x_ev=[self.ev_battery]
            #         for i in range (horizon):
            #             if i in K_ev_charging:
            #                 #z_ev.append(P_ev[i]*(60*self.time_res))
            #                 z_ev.append((P_ev[i]/self.ev.nominal_power)*(self.modified_charge_rate))
            #             else:
            #                 z_ev.append(0)
            #                 m.addConstr(P_ev[i]==0)
            #         #     #z_ewh.append(P_ewh[i]*1000*60*self.ewh.time_r*self.ewh.efficiency/(rho*(self.des_water_temp-self.tap_water_temp)))
            #         #     time_i=x_ev[0]+quicksum(z_ev[j]-shifted_demand[j] for j in range(i+1))
            #             time_i=x_ev[0]+quicksum(z_ev[j]  for j in range(i+1))
            #             x_ev.append(time_i)
                    
                    
                        
            #         ev_target=m.addConstr(x_ev[finish_charging]>=self.ev.target_charge_level)
            #         ev_capacity=m.addConstrs((x_ev[i+1]<=1 for i in range(horizon)),name='c_ev_battery_up')
            #         #     sign_of_dual_variable.extend([+1]*(1*horizon))
            # -----------------------------
            # -----------------------------
            # -----------------------------
            # -----------------------------
            # -----------------------------
            # end
                
            
        
        

        
        
        
        #-1 automatic 0 primal 1 dual 2 barrier
        m.Params.Method=0
        m.optimize()
        
        self.optimal_price = m.objVal
        
        # restrict the amount of price deviation
        if self.optimize_bill:
            
            price_flexibility=m.addConstr( quicksum(P_HVAC[i]*price[i] for i in range(horizon)) + quicksum(P_ev[i]*price[i] for i in range(horizon)) <= self.optimal_price + self.price_flexibility,name='price_flexibility')
            sign_of_dual_variable.extend([1]*(1))
            m.optimize()
            
        
        
        P_ev_a=np.zeros(horizon)
        P_hvac_a=np.zeros(horizon)
        
        
        for i in range(horizon):

            P_ev_a[i]=P_ev[i].X
            P_hvac_a[i]=P_HVAC[i].X
            
        real_power={
                 'ev':P_ev_a,
                 'hvac':P_hvac_a,
                 }
        
        
        states = {}
        # Since we use ev trajectories we do not need the code below.
        # ---------------
        # ---------------
        # ---------------
        # if self.no_ev == False:
        #     states={#'ewh':x_ewh_a,
        #              'ev_charge_percentage':P_ev_a/self.ev.nominal_power,
        #             # 'pv':x_pv_a,
        #             # 'hvac':T_in_a}
        #             }
        # else:
        #     states = {}
        # ---------------
        # ---------------
        # ---------------
        
        
        RHS=m.RHS#gives the RHS of constraints.
        A=m.getA()#gives constraint matrix
        
        dual={'RHS':RHS,
              'A': A,
              'c':modified_c,
              'dual_var_sign':sign_of_dual_variable,
              'dual_const_sign':sign_of_dual_constraint}

        
        
        return real_power,states,dual,m,p_obj
    

















